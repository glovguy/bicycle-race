<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
</head>
<body>

<canvas id="draw" width="1265" height="492"></canvas>
<p></p>
<button id="playPause" onclick="playpause();">Pause</button>
<p></p>
<button id="startMulti" onclick="startMultiplayerGame();">Start Multiplayer Game</button>

<h3>Blue: <span id="blueScore">0</span></h3>
<h3>Gold: <span id="goldScore">0</span></h3>
<textarea id="net-json" style="width:100%; height:200px; display:none;"></textarea>

<script type="text/javascript" src="https://cs.stanford.edu/people/karpathy/convnetjs/build/convnet-min.js"></script>
<script type="text/javascript" src="https://cs.stanford.edu/people/karpathy/convnetjs/build/deepqlearn.js"></script>
<script type="text/javascript" src="https://cs.stanford.edu/people/karpathy/convnetjs/build/util.js"></script>
<script src="/socket.io/socket.io.js"></script>

<script type="text/javascript" src="static/analytics.js"></script>
<script type="text/javascript" src="static/utilities.js"></script>
<script type="text/javascript" src="static/physics.js"></script>
<script type="text/javascript" src="static/brain.js"></script>
<script type="text/javascript">
  const blueScoreDisplay = document.querySelector('#blueScore');
  const goldScoreDisplay = document.querySelector('#goldScore');
  const playPauseButton = document.querySelector('#playPause');

  const mainCanvas = document.querySelector('#draw');
  const ctx = mainCanvas.getContext('2d');

  let playing = true;
  let requestId;
  let multiplayerMode;
  let multiplayerHost = false;
  let gameUuid;
  let score = { blue: 0, gold: 0 };
  let keysPressed = {};
  setBoundsOfMap(mainCanvas.width, mainCanvas.height);

  function actionInput(e) {
    if (e.keyCode == 32 && !keysPressed[32]) {this.jump(); }
    if (e.keyCode == 37) { localPlayerAgent.actions.walkingDirection = -1; }
    if (e.keyCode == 39) { localPlayerAgent.actions.walkingDirection = 1; }
  }

  function actionStop(e) {
    if (e.keyCode == 32) {
      keysPressed[32] = false;
      localPlayerAgent.actions.jumping = false;
    }
    if (e.keyCode == 37 && localPlayerAgent.actions.walkingDirection == -1) { localPlayerAgent.actions.walkingDirection = 0; }
    if (e.keyCode == 39 && localPlayerAgent.actions.walkingDirection == 1) { localPlayerAgent.actions.walkingDirection = 0; }
  }

  function jump() {
    keysPressed[32] = true;
    localPlayerAgent.actions.jumping = true;
  }

  function debrisFromUser($event) {
    allObjects.push(debrisAt($event.offsetX, $event.offsetY, 10*(Math.random()-0.5), 10*(Math.random()-0.5)));
  }

  function spawnAndEmitDebris($event) {
    debrisFromUser($event);
    socket.emit('Client payload', { debris: allObjects[allObjects.length-1] });
  }

  function resume() {
    cycleOfLife();
    playing = true;
    playPauseButton.innerHTML = 'Pause';
  }

  function pause() {
    stop();
    playPauseButton.innerHTML = 'Play';
  }

  function stop() {
    window.cancelAnimationFrame(requestId);
    requestId = undefined;
    playing = false;
  }

  function playpause() {
    playing ? pause() : resume();
  }

  function snapMoment(subject, other) {
    return [
      subject.pos.x,
      subject.pos.y,
      subject.vel.x,
      subject.vel.y,
      other.pos.x,
      other.pos.y,
      other.vel.x,
      other.vel.y,
      subject.kineticState.freefall,
      other.pos.x - subject.pos.x,
      other.pos.y - subject.pos.y,
    ];
  }

  function snapMomentAsObject(subject, other) {
    return {
      selfPosX: subject.pos.x,
      selfPosY: subject.pos.y,
      selfVelX: subject.vel.x,
      selfVelY: subject.vel.y,
      otherPosX: other.pos.x,
      otherPosY: other.pos.y,
      otherVelX: other.vel.x,
      otherVelY: other.vel.y,
      selfFreefall: subject.kineticState.freefall,
      relativePosX: other.pos.x - subject.pos.x,
      relativePosY: other.pos.y - subject.pos.y,
      walkingDirection: subject.walkingDirection,
    };
  }

  function drawWorld(canvas, allObjs) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
    allObjs.forEach(drawObject);
  }

  function actionSnapshot(subject) {
    return {
      walkingDirection: subject.walkingDirection,
      jumping: subject.jumping
    };
  }

  let brainDebounceCycles = 12;
  let currentCycle = 0;

  function cycleOfLife() {
    if (currentCycle == brainDebounceCycles) {
      currentCycle = 0;
      botBrainCycle();
    }
    currentCycle += 1;

    const collisions = findAllCollisions(allObjects);
    allObjects.forEach((obj) => {
      const agent = agentResponsibleFor(obj);
      const actions = agent ? agent.actions : {};
      physicsCycle(obj, collisions[Object.id(obj)], actions);
    });
    enforceRigidBodies(allObjects);
    agents.forEach((agent) => {
      agent.actions.jumping = false;
    });
    allObjects.forEach((obj) => {
      if (obj.display.decay !== undefined) { obj.display.decay -= 1 * timeDel; }
    });
    allObjects = allObjects.filter((obj) => obj.display.decay == undefined || obj.display.decay > 0 );

    requestId = requestAnimFrame(cycleOfLife);
    if (multiplayerHost) { socket.emit('Host payload', {allObjects}); }
    drawWorld(mainCanvas, allObjects);
  }

  function multiplayerCycle() {
    const actionsToEmit = { walkingDirection: localPlayerAgent.actions.walkingDirection };
    if (localPlayerAgent.actions.jumping) { actionsToEmit['jumping'] = true; }
    socket.emit('Client payload', { actions: [localPlayerAgent.actions] });

    const collisions = findAllCollisions(allObjects);
    allObjects.forEach((obj) => {
      const agent = agentResponsibleFor(obj);
      const actions = agent ? agent.actions : {};
      physicsCycle(obj, collisions[Object.id(obj)], actions);
    });
    enforceRigidBodies(allObjects);
    agents.forEach((agent) => {
      agent.actions.jumping = false;
    });
    allObjects.forEach((obj) => {
      if (obj.display.decay !== undefined) {
        obj.display.decay -= 1 * timeDel;
      }
    });
    allObjects = allObjects.filter((obj) => obj.display.decay == undefined || obj.display.decay > 0 );

    requestId = requestAnimFrame(multiplayerCycle);

    drawWorld(mainCanvas, allObjects);
  }

  window.addEventListener('keydown', actionInput);
  window.addEventListener('keyup', actionStop);

  let socket;

  function terminateGame() {
    if (socket) { socket.close(); }
    agents = [];
    allObjects = [];
    mainCanvas.removeEventListener('click', debrisFromUser);
    stop();
  }

  function startMultiplayerGame() {
    terminateGame();
    multiplayerMode = false;
    multiplayerHost = true;
    playPauseButton.disabled = true;
    localPlayerAgent.body = blueBody;
    onlinePlayerAgent.body = goldBody;
    agents = [localPlayerAgent, onlinePlayerAgent];
    gameUuid = Math.floor(Math.random() * 8999) + 1000;
    window.history.pushState({}, "", gameUuid);
    socket = io.connect({
      query: 'gameUuid=' + gameUuid.toString(),
      resource: "socket.io"
    });
    socket.on('Client payload from server', function(payload) {
      if (payload['debris']) { allObjects.push(payload['debris']); }
      if (payload['actions']) { onlinePlayerAgent.actions = payload['actions'][0]; }
    });
    // canvas.addEventListener('click', debrisFromUser);
    playing = true;
    cycleOfLife();
    spawnMultiplayerMatch();
    score = { blue: 0, gold: 0 };
    console.log('Started game at:', gameUuid);
  }

  function joinMultiplayerGame() {
    terminateGame();
    multiplayerMode = true;
    multiplayerHost = false;
    playPauseButton.disabled = true;
    localPlayerAgent.body = goldBody;
    onlinePlayerAgent.body = blueBody;
    agents = [localPlayerAgent, onlinePlayerAgent];
    allObjects = [];
    socket = io.connect({
      query: 'gameUuid=' + gameUuid.toString(),
      resource: "socket.io"
    });
    socket.on('Host payload from server', function(payload) {
      allObjects = payload['allObjects'];
    });
    mainCanvas.addEventListener('click', spawnAndEmitDebris);
    playing = true;
    multiplayerCycle();
    console.log('Joined multiplayer game at:', gameUuid);
  }

  function startGameAgainstBot() {
    terminateGame();
    multiplayerMode = false;
    playPauseButton.disabled = false;
    mainCanvas.addEventListener('click', debrisFromUser);
    playing = true;
    localPlayerAgent.body = blueBody;
    // sinusoidalAgent.body = blueBody;
    // sinusoidalAgent.enemy = goldBody;
    neuralNetAgent.body = goldBody;
    neuralNetAgent.enemy = blueBody;
    agents = [localPlayerAgent, neuralNetAgent];
    cycleOfLife();
    if (agents.length > 1) {
      window.setTimeout(() => {
        respawn(bot);
      }, 1000*60);
    }
    spawnMultiplayerMatch();
    agents.push(neuralNetAgent);
    score = { blue: 0, gold: 0 };
    console.log('Started game at:', gameUuid);
  }

  if (window.location.pathname !== '/') {
    gameUuid = parseInt(window.location.pathname.match(/([0-9]){4}/)[0]);
    joinMultiplayerGame();
  } else {
    startGameAgainstBot();
  }

</script>

</body>
</html>
